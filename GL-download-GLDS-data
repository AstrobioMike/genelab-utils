#!/usr/bin/env python

"""
This is a program for downloading GLDS data files using the output table generated by the 
GL-get-GLDS-files-info program. That needs to be run first.
"""

import os
import sys
import argparse
import textwrap
import pandas as pd
from time import sleep
import subprocess


parser = argparse.ArgumentParser(description = "This is a program for downloading GLDS data files using the \
                                                output table generated by the `GL-get-GLDS-files-info` program. \
                                                So see that first if you haven't yet. For version info, run \
                                                `GL-version`.")

required = parser.add_argument_group('required arguments')

required.add_argument("-i", "--input-table", help = 'This should be the tsv table produced by the `GL-get-GLDS-files-info` \
                      program', action = "store", required = True)
required.add_argument("-p", "--pattern", help = "If we do not want to download all files (which we often won't), we can specify \
                      a pattern here to subset the total files. For example, if we know we want to download just the fastq.gz \
                      files, we can say '-p fastq.gz'. We can also provide multiple patterns as a comma-separated list. For example, \
                      If we want to download the fastq.gz files that also have 'NxtaFlex', 'metagenomics', and 'raw' in their filenames, we can provide \
                      '-p fastq.gz,NxtaFlex,metagenomics,raw'. Looking through the table produced by the `GL-get-GLDS-files-info` program \
                      can help figure this out if needed. (Note that this is case-sensitive.)", action = "store", type = str)

parser.add_argument("-j", "--jobs", help = "Number of downloads to run in parallel (default: 10)", default = 10, action = "store", type = int)

parser.add_argument("--print-only", help = "Just print out the files that would be downloaded, rather than downloading them\
                                                  (useful to check we are getting what we want first)", action = "store_true")


if len(sys.argv)==1:
    parser.print_help(sys.stderr)
    sys.exit(0)

args = parser.parse_args()

download_commands_file = "download-commands.sh"
not_downloaded_files_file = "files-not-downloaded.txt"

################################################################################

def main():

    # reading input table into dataframe
    in_tab = pd.read_csv(args.input_table, sep = "\t")

    # check headers are as expected as one way to check this input file came from GL-get-GLDS-files-info
    if in_tab.columns.values[0] != "filename" or in_tab.columns.values[1] != "url":
        report_message("The provided input table doesn't match what we expect from the 'GL-get-GLDS-files-info' program, and that is required :(")
        print("")
        exit(1)

    # number of total files
    num_total_files = len(in_tab.index)

    report_message(f"The input table holds a total of {num_total_files} files.")
    print("")
    sleep(1)

    if args.pattern:

        # splitting if any commas
        if "," in args.pattern:

            patterns = args.pattern.split(",")

        else:

            patterns = [args.pattern]

        download_tab = in_tab
        for pattern in patterns:

            download_tab = download_tab[download_tab['filename'].str.contains(pattern)]

        # number of files after filtering
        num_files_to_download = len(download_tab.index)

        if num_files_to_download == 0:

            report_message(f"No files were found matching the specified patterns :(")
            print("")
            exit(0)

        report_message(f"{num_files_to_download} files were found matching the provided pattern(s).")
        print("")
        sleep(1)

    else:
        num_files_to_download = num_total_files
        download_tab = in_tab

    if args.print_only:

        report_message(f"As requested, here are the {num_files_to_download} files that would be downloaded by this command if run without the '--print-only' flag:")
        print()
        sleep(2.5)

        for filename in download_tab.filename:
            print(f"    {filename}")
            sleep(0.01)

        print("")
        exit(0)

    else:

        report_message(f"If you'd just like to see a list of the files that would be downloaded, here is your chance to exit and rerun the command with the '--print-only' flag...")
        sleep(3)
        print("")

    print(f"    Enter 'y' if you'd like to begin downloading these {num_files_to_download} files,")
    response = input("    enter any other key to exit without downloading: ")

    if response != "y":

        report_message(f"Exiting without downloading :)")
        print("")
        exit(0)

    else:

        print("")

        # building download script based on curl
        beginning_of_command = "curl -L -s -o"

        with open(download_commands_file, "w") as download_script:

            for index, row in download_tab.iterrows():

                filename = row["filename"]
                url = row["url"]

                download_script.write(f"{beginning_of_command} {filename} {url}\n")


        report_message(f"Beginning download of the {num_files_to_download} files...")
        print("")

        dl_command = f"parallel --xapply -j {args.jobs} < {download_commands_file}"

        subprocess.run(dl_command, shell = True)
        
        # checking expected files were downloaded
        cwd_files = os.listdir(".")

        missing_files = []

        for file in download_tab.filename:

            if file not in cwd_files:

                missing_files.append(file)

        num_missing = len(missing_files)

        if num_missing > 0:

            with open(not_downloaded_files_file, "w") as out_file:
                for file in missing_files:
                    out_file.write(f"{file}\n")

            report_message(f"Some files ({num_missing}) weren't successfully downloaded for some reason. They have been written to:")
            print(f"    {not_downloaded_files_file}\n")

        else:

            report_message(f"All {num_files_to_download} files have been downloaded :)", "green")
            print("")

        report_message(f"The commands executed were written to:")
        print(f"    {download_commands_file}\n")


################################################################################

# setting some colors
tty_colors = {
    'green' : '\033[0;32m%s\033[0m',
    'yellow' : '\033[0;33m%s\033[0m',
    'red' : '\033[0;31m%s\033[0m'
}


### functions ###
def color_text(text, color='green'):
    if sys.stdout.isatty():
        return tty_colors[color] % text
    else:
        return text


def wprint(text):
    """ print wrapper """

    print(textwrap.fill(text, width=80, initial_indent="  ",
          subsequent_indent="  ", break_on_hyphens=False))


def report_failure(message, color = "yellow"):
    print("")
    wprint(color_text(message, color))
    print("\nData file info download failed.\n")
    sys.exit(1)


def report_message(message, color = "yellow"):
    print("")
    wprint(color_text(message, color))

if __name__ == "__main__":
    main()
